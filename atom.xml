<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Daniel's Blog]]></title>
  <subtitle><![CDATA[Stay hungry，Stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yerida.github.io/"/>
  <updated>2016-01-24T14:06:12.000Z</updated>
  <id>http://yerida.github.io/</id>
  
  <author>
    <name><![CDATA[Daniel Ye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JDK安装及环境变量配置]]></title>
    <link href="http://yerida.github.io/2016/01/18/JDK-install/"/>
    <id>http://yerida.github.io/2016/01/18/JDK-install/</id>
    <published>2016-01-18T13:47:55.000Z</published>
    <updated>2016-01-24T14:06:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK官方网站</a>下载最新版本的JDK, 或者从<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="external">JDK Archive</a>找早期的版本（目前JDK6还是很流行的，某些情况下，需要安装早期的版本），这里以JDK6作为例子。</li>
<li>根据操作系统的位数，32位下载X86安装包,  64位的下载X64的安装包。这里以<a href="http://download.oracle.com/otn/java/jdk/6u43-b01/jdk-6u43-windows-i586.exe" target="_blank" rel="external">jdk-6u43-windows-i586.exe</a>为例。</li>
<li>安装的时候，默认是安装在<code>C:\Program Files\Java</code>或者<code>C:\Program Files (x86)\Java</code>路径下，强烈建议不要安装在此路径下，因为这个路径的<code>Program Files</code>目录名中的空格有时候会引起一些问题。建议直接安装在<code>C:\Java</code>路径下。</li>
<li>环境变量配置（右击计算机–&gt;属性–&gt;高级系统设置–&gt;高级–&gt;环境变量）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量值</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JAVA_HOME</td>
<td style="text-align:left"><code>C:\Java\jdk1.6.0_43</code></td>
<td style="text-align:left">JDK安装的目录</td>
</tr>
<tr>
<td style="text-align:left">Path</td>
<td style="text-align:left"><code>;%JAVA_HOME%\bin</code></td>
<td style="text-align:left">在原来的Path变量值后面添加</td>
</tr>
<tr>
<td style="text-align:left">CLASSPATH</td>
<td style="text-align:left"><code>.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar</code></td>
<td style="text-align:left">注意，变量值里面有个”.” ，代表当前路径</td>
</tr>
</tbody>
</table>
<p>5.测试JDK是否安装成功。<strong>新打开</strong>一个cmd命令窗口，输入<code>java –version</code>, 如果有输出JDK的版本信息，则说明安装成功。可以在写个打印”Hello World”的程序测试一下。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><em>这里以<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>为例</em></p>
<ol>
<li>在安装之前，先查看系统是否已经预装了OpenJDK软件，可以在终端执行以下命令。<br><code>java -version</code>如果有输出OpenJDK相关的信息，说明系统已经预装了OpenJDK软件，需要先卸载OpenJDK，卸载方法到网上搜索。</li>
<li>下载安装包<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>。假设安装包下载到<code>/home/yerida/Downloads</code>目录。</li>
<li><p>进入<code>/usr/local</code>目录，在该目录下创建一个java子目录,并进入该java子目录,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span></span><br><span class="line"><span class="variable">$sudo</span> mkdir java</span><br><span class="line"><span class="variable">$cd</span> java</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装包复制到该java目录，并为该安装包添加执行权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> cp /home/yerida/Downloads/jdk-<span class="number">6</span>u45-linux-i586.bin /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$sudo</span> chmod a+x jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行该安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ./jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装后<code>/usr/local/java</code>目录下多了一个<code>jdk1.6.0_45</code>子目录,创建一个软连接指向该目录,并删除安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ln <span class="operator">-s</span> jdk1.<span class="number">6.0</span>_45 jdk  </span><br><span class="line"><span class="variable">$sudo</span> rm jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量。用VIM打开<code>/etc/profile</code>文件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加如下内容，保存并退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk&#10;JRE_HOME=$JAVA_HOME/jre&#10;PATH=$JAVA_HOME/bin:$PATH&#10;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/toos.jar&#10;export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置立即生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Mac_OS_X"><a href="#Mac_OS_X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><p>Mac OS X系统下可以使用<code>brew cask</code>来安装JDK，这种方法非常简单。</p>
<ol>
<li><p>首先用以下命令查找可用的JDK安装包。<br><code>brew cask search java</code></p>
</li>
<li><p>安装最新版本的JDK使用如下命令<br><code>brew cask install java</code></p>
</li>
<li><p>如果要安装其他版本的JDK<br>JDK7安装 <code>brew cask search java7</code><br>JDK6安装 <code>brew cask search java6</code></p>
</li>
<li>测试安装是否成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Mac OS X系统按以上步骤安装好后<strong>无需</strong>在配置JAVA_HOME环境变量,如果系统安装了多个JDK，使用IDE开发的时候可以指定具体的版本，终端下可以使用<code>/usr/libexec/java_home</code>命令来查找JAVA_HOME或者切换JDK版本。参考Apple官方文档：<a href="https://developer.apple.com/library/mac/qa/qa1170/_index.html" target="_blank" rel="external">Important Java Directories on Mac OS X</a></p>
<h1 id="Hello_World_u6D4B_u8BD5_u7A0B_u5E8F"><a href="#Hello_World_u6D4B_u8BD5_u7A0B_u5E8F" class="headerlink" title="Hello World测试程序"></a>Hello World测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<br><code>$javac HelloWorld.java</code></p>
<p>运行：<br><code>$java HelloWorld</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/]]>
    </summary>
    
      <category term="Java" scheme="http://yerida.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://yerida.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Test first post]]></title>
    <link href="http://yerida.github.io/2016/01/13/my-new-post/"/>
    <id>http://yerida.github.io/2016/01/13/my-new-post/</id>
    <published>2016-01-13T14:16:50.000Z</published>
    <updated>2016-01-13T15:11:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h1><h2 id="u8FD9_u662F_H2"><a href="#u8FD9_u662F_H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h6 id="u8FD9_u662F_H6"><a href="#u8FD9_u662F_H6" class="headerlink" title="这是 H6"></a>这是 H6</h6><hr>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h1><h2 id="u8FD9_u662F_H2"><a href="#u8FD9_u662F_H2" class]]>
    </summary>
    
      <category term="Blog" scheme="http://yerida.github.io/tags/Blog/"/>
    
      <category term="blog" scheme="http://yerida.github.io/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yerida.github.io/2016/01/13/hello-world/"/>
    <id>http://yerida.github.io/2016/01/13/hello-world/</id>
    <published>2016-01-13T13:23:21.000Z</published>
    <updated>2016-01-13T13:23:21.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <link href="http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/"/>
    <id>http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/</id>
    <published>2013-04-26T07:18:27.000Z</published>
    <updated>2016-01-27T14:38:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h1><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。</p>
<p><strong>关键点：</strong></p>
<p>单例模式的要点有三个:</p>
<ol>
<li>一是某个类只能有一个实例.</li>
<li>二是它必须自行创建这个实例.</li>
<li>三是它必须自行向整个系统提供这个实例。</li>
</ol>
<p>从具体实现角度来说，就是以下三点：</p>
<ol>
<li>一是单例模式的类只提供私有的构造方法.</li>
<li>二是类定义中含有一个该类的静态私有对象.</li>
<li>三是该类提供了一个静态的公有的方法用于创建或获取它本身的静态私有对象。</li>
</ol>
<h1 id="u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A"><a href="#u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A" class="headerlink" title="单例模式UML图:"></a>单例模式UML图:</h1><p><img src="https://raw.githubusercontent.com/yerida/BlogImage/master/designpattern/uml_singleton.jpg" alt=""></p>
<h1 id="u5B9E_u73B0_u65B9_u5F0F_uFF1A"><a href="#u5B9E_u73B0_u65B9_u5F0F_uFF1A" class="headerlink" title="实现方式："></a>实现方式：</h1><h2 id="u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，非线程安全"></a>懒汉式，非线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong>在多线程环境下可能产生多个实例，违背单例原则。</p>
<h2 id="u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是在方法级别上synchronized并不高效，理论上只需要在第一次调用getInstance() 才需要同步操作。 </p>
<h2 id="u997F_u6C49_u5F0F"><a href="#u997F_u6C49_u5F0F" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。在延迟加载的场景并不适用。</p>
<h2 id="u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29"><a href="#u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29" class="headerlink" title="双重检验锁(DCL)"></a>双重检验锁(DCL)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><strong>缺点：</strong>实现比较复杂，并且由于Java5 以前的JMM（Java 内存模型）存在缺陷，该实现方式会有问题, Java5 和更高的版本可以使用。</p>
<h2 id="u9759_u6001_u5185_u90E8_u7C7B"><a href="#u9759_u6001_u5185_u90E8_u7C7B" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>使用JVM本身机制保证了线程安全问题；SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。</p>
<h2 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法是《Effective Java》上推荐的写法。</em><br><strong>优点</strong>：实现很简单，创建枚举本来就是线程安全的，还能防止反序列化导致重新创建新的对象，直接通过Singleton.INSTANCE来访问实例。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>第一种方法是非线程安全的，不能算正确的写法，有些书上就是这么写的误人子弟啊。 其他方法根据实际情况来选择。<br>一般情况下使用饿汉式写法就可以了，除非有明确要求要用延迟加载（Lazy Loading），这时候可以考虑另外几种实现方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h1]]>
    </summary>
    
      <category term="设计模式" scheme="http://yerida.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://yerida.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux write系统调用问题(对齐问题)]]></title>
    <link href="http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/"/>
    <id>http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/</id>
    <published>2012-01-20T12:55:45.000Z</published>
    <updated>2016-01-21T14:33:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((write(<span class="number">1</span>, <span class="string">"Here is some data\n"</span>, <span class="number">18</span>)) != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后在终端中运行，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data</span><br></pre></td></tr></table></figure></p>
<p>如果稍微改变一下write的实参值，将第一个write函数的第三个参数改为17，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>将18改为20，在终端中运行的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data&#10;A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>此程序没有疑问。</p>
<p>程序2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nb;</span><br><span class="line">    nb = (<span class="keyword">int</span>)write(<span class="number">1</span>, <span class="string">"Here is some\n"</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nThe value returned by the function write is %d\n"</span>, nb);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some&#10;A&#10;The value returned by function write is 18</span><br></pre></td></tr></table></figure></p>
<p>程序2运行后，第二行为什么会输出一个A ？ 这个A明显是if语句块里的那个write函数的结果。如果nb的值确实是18，那么按理来说，if语句就不会执行，就不会有这个A；如果nb的值不是18，那么按理第二行应该输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A error has occured on file descriptior 1\n</span><br></pre></td></tr></table></figure></p>
<p>原因分析如下：</p>
<p>常量字符串按顺序存储在常量区域的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34;Here is some\n&#34;&#10;&#34;A error has occured on file descriptior 1\n&#34;</span><br></pre></td></tr></table></figure></p>
<p>这两个常量字符串的地址是紧挨着的, 当第一个字符串的访问越界后就访问到第二个字符串了。</p>
<p>考虑下对齐，指针的地址通常需要是 32 位对齐，也就是 4 的倍数。所以前面的 14 个字符会被多填充两个 0 来对齐到 16 个字节，在加上后面的 A 和一个空格, 刚好 18 个。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1]]>
    </summary>
    
      <category term="C/C++" scheme="http://yerida.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="http://yerida.github.io/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://yerida.github.io/categories/C-C/"/>
    
  </entry>
  
</feed>
