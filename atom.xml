<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Daniel's Blog]]></title>
  <subtitle><![CDATA[Stay hungry，Stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yerida.github.io/"/>
  <updated>2016-02-03T15:52:53.000Z</updated>
  <id>http://yerida.github.io/</id>
  
  <author>
    <name><![CDATA[Daniel Ye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[IntelliJ IDEA 15常用快捷键(Mac)]]></title>
    <link href="http://yerida.github.io/2015/05/13/intellij-idea-15-keyboard-shortcuts-you-cannot-miss/"/>
    <id>http://yerida.github.io/2015/05/13/intellij-idea-15-keyboard-shortcuts-you-cannot-miss/</id>
    <published>2015-05-13T07:58:01.000Z</published>
    <updated>2016-02-03T15:52:53.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>通过名字查找功能    <code>⇧⌘A</code></li>
<li>显示可用的功能列表 <code>⌥⏎</code></li>
<li>视图切换    <code>⌥F1</code></li>
<li>在工具窗口切换，编辑器里已打开的文件切换    <code>⌃⇥</code></li>
<li>显示导航栏     <code>⌘↑</code></li>
<li>插入live template.     <code>⌘J</code></li>
<li>Surround with a live template.    <code>⌥⌘J</code></li>
<li>从项目或者其他树形视图编辑条目    <code>⌘↓</code></li>
<li>代码注释和取消注释    <code>⌘/</code>  <code>⌥⌘/</code></li>
<li>通过名字查找类或者文件    <code>⌘O</code>   <code>⇧⌘O</code></li>
<li>复制当前行或者选中的区域    <code>⌘D</code></li>
<li>Incremental expression selection.    <code>⌥↑</code> and <code>⌥↓</code></li>
<li>在当前文件内查找文本    <code>⌘F</code></li>
<li>在当前的项目或者指定的目录查找文本    <code>⇧⌘F</code></li>
<li>Search everywhere.    <code>按两下Shift</code></li>
<li>Quick view the usages of the selected symbol.    <code>⇧⌘F7</code></li>
<li>在编辑器里展开或折叠代码块     <code>⌘+</code>  <code>⌘-</code></li>
<li>Invoke code completion.    <code>⌃Space</code></li>
<li>Smart statement completion.    <code>⇧⌘⏎</code></li>
<li><p>代码智能补全    <code>⌃⇧Space</code></p>
<p>完整快捷键列表:<a href="https://www.jetbrains.com/idea/help/keyboard-shortcuts-by-category.html" target="_blank" rel="external">https://www.jetbrains.com/idea/help/keyboard-shortcuts-by-category.html</a></p>
<p>Keymap:<a href="https://www.jetbrains.com/idea/help/keymap.html" target="_blank" rel="external">https://www.jetbrains.com/idea/help/keymap.html</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>通过名字查找功能    <code>⇧⌘A</code></li>
<li>显示可用的功能列表 <code>⌥⏎</code></li>
<li>视图切换    <code>⌥F1</code></li>
<li>在工具窗口切换，编辑器里已打开的文件切换    ]]>
    </summary>
    
      <category term="IDE" scheme="http://yerida.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的注解(Annotation)工作原理]]></title>
    <link href="http://yerida.github.io/2015/05/01/How-Java-Annotation-work/"/>
    <id>http://yerida.github.io/2015/05/01/How-Java-Annotation-work/</id>
    <published>2015-04-30T16:16:08.000Z</published>
    <updated>2016-02-29T16:32:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>Java从5.0版本引入注解，现在它已经是Java平台中非常重要的一部分。开发过程中，我们也时常在应用代码中会看到诸如<code>@Override</code>，<code>@Deprecated</code>这样的注解。这里主要介绍注解的工作原理和编程实现。</p>
<p><img src="http://www.importnew.com/wp-content/uploads/2014/03/55211fcb7df719e4ccdff7569873be0a.png" alt=""></p>
<h2 id="u4EC0_u4E48_u662F_u6CE8_u89E3_28Annotation_29_uFF1F"><a href="#u4EC0_u4E48_u662F_u6CE8_u89E3_28Annotation_29_uFF1F" class="headerlink" title="什么是注解(Annotation)？"></a>什么是注解(Annotation)？</h2><p>用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。比如，下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is String Representation of current object."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，重写了toString()方法并使用了<code>@Override</code>注解。但是，即使不使用<code>@Override</code>注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果不小心拼写错误，例如将toString()写成了toStrring(){double r}，并且没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和期望的不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p>
<p>Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由<code>JSR-175</code>标准选择用来描述元数据的一种工具。</p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u5F15_u5165_u6CE8_u89E3_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u8981_u5F15_u5165_u6CE8_u89E3_uFF1F" class="headerlink" title="为什么要引入注解？"></a>为什么要引入注解？</h2><p>使用Annotation之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>另一个很重要的因素是Annotation定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像Annotation这种标准的方式。</p>
<p>目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<h2 id="Annotation_u662F_u5982_u4F55_u5DE5_u4F5C_u7684_uFF1F_u600E_u4E48_u7F16_u5199_u81EA_u5B9A_u4E49_u7684Annotation_uFF1F"><a href="#Annotation_u662F_u5982_u4F55_u5DE5_u4F5C_u7684_uFF1F_u600E_u4E48_u7F16_u5199_u81EA_u5B9A_u4E49_u7684Annotation_uFF1F" class="headerlink" title="Annotation是如何工作的？怎么编写自定义的Annotation？"></a>Annotation是如何工作的？怎么编写自定义的Annotation？</h2><p>在讲述这部分之前，建议你首先下载Annotation的示例代码AnnotationsSample.zip 。下载之后放在你习惯使用的IDE中，这些代码会帮助你更好的理解Annotation机制。</p>
<p>编写Annotation非常简单，可以将Annotation的定义同接口的定义进行比较。我们来看两个例子：一个是标准的注解<code>@Override</code>，另一个是用户自定义注解<code>@Todo</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">	<span class="keyword">public</span> <span class="annotation">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>@Override</code>注释你可能有些疑问，它什么都没做，那它是如何检查在父类中有一个同名的函数呢。当然，不要惊讶，我是逗你玩的。<code>@Override</code>注解的定义不仅仅只有这么一点代码。这部分内容很重要，我不得不再次重复：Annotations仅仅是元数据，和业务逻辑无关。理解起来有点困难，但就是这样。如果Annotations不包含业务逻辑，那么必须有人来实现这些逻辑。元数据的用户来做这个事情。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息。Annotations的用户(同样是一些代码)来读取这些信息并实现必要的逻辑。</p>
<p>当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。到这里，应用开发人员还不能控制也不能使用自定义的注解。因此，我们讲解一下如何编写自定义的Annotations。</p>
<p>我们来逐个讲述编写自定义Annotations的要点。上面的例子中，你看到一些注解应用在注解上。</p>
<p>J2SE5.0版本在<code>java.lang.annotation</code>提供了四种元注解，专门注解其他的注解：</p>
<p><code>@Documented</code> –注解是否将包含在JavaDoc中<br><code>@Retention</code> –什么时候使用该注解<br><code>@Target</code> –注解用于什么地方<br><code>@Inherited</code> – 是否允许子类继承该注解</p>
<p><code>@Documented</code>–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。</p>
<p><code>@Retention</code>– 定义该注解的生命周期。</p>
<p><code>RetentionPolicy.SOURCE</code> – 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</p>
<p><code>RetentionPolicy.CLASS</code> – 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。</p>
<p><code>RetentionPolicy.RUNTIME</code>– 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p>
<p><code>@Target</code> – 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可用的参数。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。</p>
<p>ElementType.TYPE:用于描述类、接口或enum声明<br>ElementType.FIELD:用于描述实例变量<br>ElementType.METHOD<br>ElementType.PARAMETER<br>ElementType.CONSTRUCTOR<br>ElementType.LOCAL_VARIABLE<br>ElementType.ANNOTATION_TYPE 另一个注释<br>ElementType.PACKAGE 用于记录java文件的package信息</p>
<p><code>@Inherited</code> – 定义该注释和子类的关系</p>
<p>那么，注解的内部到底是如何定义的呢？Annotations只支持基本类型、String及枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@interface</span> Todo &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;STARTED, NOT_STARTED&#125;</span><br><span class="line">	<span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "Yash"</span>;</span><br><span class="line">	<span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</span><br><span class="line">	<span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.NOT_STARTED</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子演示了如何使用上面的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Todo</span>(priority = Todo.Priority.MEDIUM, author = <span class="string">"Yashwant"</span>, status = Todo.Status.STARTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Some business logic is written</span></span><br><span class="line"><span class="comment">//But it’s not complete yet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果注解中只有一个属性，可以直接命名为“value”，使用时无需再标明属性名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> Author&#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Author</span>(<span class="string">"Yashwant"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但目前为止一切看起来都还不错。我们定义了自己的注解并将其应用在业务逻辑的方法上。现在我们需要写一个用户程序调用我们的注解。这里我们需要使用反射机制。如果你熟悉反射代码，就会知道反射可以提供类名、方法和实例变量对象。所有这些对象都有<code>getAnnotation()</code>这个方法用来返回注解信息。我们需要把这个对象转换为我们自定义的注释(使用 <code>instanceOf()</code>检查之后)，同时也可以调用自定义注释里面的方法。看看以下的实例代码，使用了上面的注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class businessLogicClass = BusinessLogic.class;</span><br><span class="line"><span class="keyword">for</span>(Method method : businessLogicClass.getMethods()) &#123;</span><br><span class="line">Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);</span><br><span class="line"><span class="keyword">if</span>(todoAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">" Method Name : "</span> + method.getName());</span><br><span class="line">		System.out.println(<span class="string">" Author : "</span> + todoAnnotation.author());</span><br><span class="line">		System.out.println(<span class="string">" Priority : "</span> + todoAnnotation.priority());</span><br><span class="line">		System.out.println(<span class="string">" Status : "</span> + todoAnnotation.status());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解用例</p>
<p>注解的功能很强大，Spring和Hebernate这些框架在日志和有效性中大量使用了注解功能。注解可以应用在使用标记接口的地方。不同的是标记接口用来定义完整的类，但你可以为单个的方法定义注释，例如是否将一个方法暴露为服务。</p>
<p>在最新的Servlet3.0中引入了很多新的注解，尤其是和servlet安全相关的注解。</p>
<p><code>HandlesTypes</code> –该注解用来表示一组传递给ServletContainerInitializer的应用类。</p>
<p><code>HttpConstraint</code> – 该注解代表所有HTTP方法的应用请求的安全约束，和ServletSecurity注释中定义的HttpMethodConstraint安全约束不同。</p>
<p><code>HttpMethodConstraint</code> – 指明不同类型请求的安全约束，和ServletSecurity 注解中描述HTTP协议方法类型的注释不同。</p>
<p><code>MultipartConfig</code> –该注解标注在Servlet上面，表示该Servlet希望处理的请求的 MIME 类型是 multipart/form-data。</p>
<p><code>ServletSecurity</code> 该注解标注在Servlet继承类上面，强制该HTTP协议请求遵循安全约束。</p>
<p><code>WebFilter</code> – 该注解用来声明一个Server过滤器；</p>
<p><code>WebInitParam</code> – 该注解用来声明Servlet或是过滤器的中的初始化参数，通常配合 @WebServlet 或者 @WebFilter 使用。</p>
<p><code>WebListener</code> –该注解为Web应用程序上下文中不同类型的事件声明监听器。</p>
<p><code>WebServlet</code> –该注解用来声明一个Servlet的配置。</p>
<h2 id="ADF__28_u5E94_u7528_u7A0B_u5E8F_u6846_u67B6_29_u548C_u6CE8_u89E3"><a href="#ADF__28_u5E94_u7528_u7A0B_u5E8F_u6846_u67B6_29_u548C_u6CE8_u89E3" class="headerlink" title="ADF (应用程序框架)和注解"></a>ADF (应用程序框架)和注解</h2><p>现在我们开始讨论文章的最后一部分了。应用程序框架，被称为<code>ADF</code>，由Oracle开发用来创建Oracle融合应用。我们已经了解了注解的优缺点，也知道如何编写自定义的注解，但我们应该将注解应用在ADF的哪部分呢？ADF是否提供了一些朴素的注解？很好的问题，确实在ADF中大量使用注解有一些限制。之前提到的应用框架如Spring和Hibernate使用AOP(面向侧面的程序设计)。在AOP中，框架提供了一种机制，在事件的预处理和后续处理中注入代码。例如：你有一个钩子用来在方法执行之前和之后添加代码，所以你可以在这些地方编写你的用户代码。ADF不使用AOP。如果我们有任何注解的用例可用，我们可能需要通过继承的方式实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>Java从5.0版本引入注解，现在它已经是Java平台中非常重要的一部分。开发过程中，我们也时常在应用代]]>
    </summary>
    
      <category term="Java" scheme="http://yerida.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解Git]]></title>
    <link href="http://yerida.github.io/2014/03/02/visual-git-guide/"/>
    <id>http://yerida.github.io/2014/03/02/visual-git-guide/</id>
    <published>2014-03-02T05:42:33.000Z</published>
    <updated>2016-02-03T13:19:54.000Z</updated>
    <content type="html"><![CDATA[<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h2><p><img src="http://marklodato.github.io/visual-git-guide/basic-usage.svg" alt=""></p>
<p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p>
<ul>
<li><code>git add files</code> 把当前文件放入暂存区域。</li>
<li><code>git commit</code> 给暂存区域生成快照并提交。</li>
<li><code>git reset -- files</code> 用来撤销最后一次<code>git add files</code>，你也可以用<code>git reset</code> 撤销所有暂存区域文件。</li>
<li><code>git checkout -- files</code> 把文件从暂存区域复制到工作目录，用来丢弃本地修改。<br>你可以用 <code>git reset -p</code>, <code>git checkout -p</code>, or <code>git add -p</code>进入交互模式。</li>
</ul>
<p>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/basic-usage-2.svg" alt=""></p>
<ul>
<li><code>git commit -a</code> 相当于运行 <code>git add</code> 把所有当前目录下的文件加入暂存区域再运行 <code>git commit</code>.</li>
<li><code>git commit files</code> 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。</li>
<li><code>git checkout HEAD -- files</code> 回滚到复制最后一次提交。</li>
</ul>
<h2 id="u7EA6_u5B9A"><a href="#u7EA6_u5B9A" class="headerlink" title="约定"></a>约定</h2><p>后文中以下面的形式使用图片。<br><img src="http://marklodato.github.io/visual-git-guide/conventions.svg" alt=""></p>
<p>绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的<em>HEAD</em>标识。 这张图片里显示最后5次提交，<em>ed489</em>是最新提交。 <em>master</em>分支指向此次提交，另一个<em>maint</em>分支指向祖父提交节点。</p>
<h2 id="u547D_u4EE4_u8BE6_u89E3"><a href="#u547D_u4EE4_u8BE6_u89E3" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>有许多种方法查看两次提交之间的变动。下面是一些示例。<br><img src="http://marklodato.github.io/visual-git-guide/diff.svg" alt=""></p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>commit</code>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。<br><img src="http://marklodato.github.io/visual-git-guide/commit-master.svg" alt=""></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。此时，合并(<code>merge</code>) 或者 衍合(<code>rebase</code>) 是必须的。<br><img src="http://marklodato.github.io/visual-git-guide/commit-maint.svg" alt=""></p>
<p>如果想更改一次提交，使用 <code>git commit --amend</code>。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p>另一个例子是分离HEAD提交,后文讲。</p>
<h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p><code>checkout</code>命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>当给定某个文件名（或者打开｀-p｀选项，或者文件名和｀-p｀选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，<code>git checkout HEAD~ foo.c</code>会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-files.svg" alt=""></p>
<p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的<em>a47c3</em>）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（<em>ed489</em>）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-branch.svg" alt=""></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像master~3类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行<code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说<code>git checkout master</code>。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在下面。<br><img src="http://marklodato.github.io/visual-git-guide/checkout-detached.svg" alt=""></p>
<p><strong>HEAD标识处于分离状态时的提交操作</strong></p>
<p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p>
<p><img src="http://marklodato.github.io/visual-git-guide/commit-detached.svg" alt=""></p>
<p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-after-detached.svg" alt=""></p>
<p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b name</code>来创建一个新的分支。<br><img src="http://marklodato.github.io/visual-git-guide/checkout-b-detached.svg" alt=""></p>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p><code>reset</code>命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用<code>--hard</code>选项，那么工作目录也更新，如果用<code>--soft</code>选项，那么都不变。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset-commit.svg" alt=""></p>
<p>如果没有给出提交点的版本号，那么默认用<em>HEAD</em>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用<code>--hard</code>选项，工作目录也同样。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset.svg" alt=""></p>
<p>如果给了文件名(或者 <code>-p</code>选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset-files.svg" alt=""></p>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>merge</code> 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致<em>fast-forward</em>合并。指向只是简单的移动，并生成一个新的提交。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/merge-ff.svg" alt=""></p>
<p>否则就是一次真正的合并。默认把当前提交(<em>ed489</em> 如下所示)和另一个提交(<em>33104</em>)以及他们的共同祖父节点(<em>b325c</em>)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。<br><img src="http://marklodato.github.io/visual-git-guide/merge.svg" alt=""></p>
<h3 id="Cherry_Pick"><a href="#Cherry_Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h3><p><code>cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br><img src="http://marklodato.github.io/visual-git-guide/cherry-pick.svg" alt=""></p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>rebase</code>(衍合)是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick<br><img src="http://marklodato.github.io/visual-git-guide/rebase.svg" alt=""></p>
<p>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支，在<em>master</em>分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p>
<p>要限制回滚范围，使用<code>--onto</code>选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/rebase-onto.svg" alt=""></p>
<p>同样有<code>git rebase --interactive</code>让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。没有图片体现这些，细节看这里:<a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode" target="_blank" rel="external">git-rebase(1)</a></p>
<h2 id="u6280_u672F_u8BF4_u660E"><a href="#u6280_u672F_u8BF4_u660E" class="headerlink" title="技术说明"></a>技术说明</h2><p>文件内容并没有真正存储在索引(<em>.git/index</em>)或者提交对象中，而是以blob的形式分别存储在数据库中(<em>.git/objects</em>)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(<em>tree</em>)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p>
<p>如果用<code>detached HEAD</code>提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与<code>git commit --amend</code>或者<code>git rebase</code>很像。</p>
<blockquote>
<p>原文地址: <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink"]]>
    </summary>
    
      <category term="Git" scheme="http://yerida.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <link href="http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/"/>
    <id>http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/</id>
    <published>2013-04-26T07:18:27.000Z</published>
    <updated>2016-02-16T14:41:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。</p>
<p><strong>关键点：</strong></p>
<p>单例模式的要点有三个:</p>
<ol>
<li>一是某个类只能有一个实例.</li>
<li>二是它必须自行创建这个实例.</li>
<li>三是它必须自行向整个系统提供这个实例。</li>
</ol>
<p>从具体实现角度来说，就是以下三点：</p>
<ol>
<li>一是单例模式的类只提供私有的构造方法.</li>
<li>二是类定义中含有一个该类的静态私有对象.</li>
<li>三是该类提供了一个静态的公有的方法用于创建或获取它本身的静态私有对象。</li>
</ol>
<h2 id="u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A"><a href="#u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A" class="headerlink" title="单例模式UML图:"></a>单例模式UML图:</h2><p><img src="https://raw.githubusercontent.com/yerida/BlogImage/master/designpattern/uml_singleton.jpg" alt=""></p>
<h2 id="u5B9E_u73B0_u65B9_u5F0F_uFF1A"><a href="#u5B9E_u73B0_u65B9_u5F0F_uFF1A" class="headerlink" title="实现方式："></a>实现方式：</h2><h3 id="u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，非线程安全"></a>懒汉式，非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong>在多线程环境下可能产生多个实例，违背单例原则。</p>
<h3 id="u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是在方法级别上synchronized并不高效，理论上只需要在第一次调用getInstance() 才需要同步操作。 </p>
<h3 id="u997F_u6C49_u5F0F"><a href="#u997F_u6C49_u5F0F" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。在延迟加载的场景并不适用。</p>
<h3 id="u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29"><a href="#u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29" class="headerlink" title="双重检验锁(DCL)"></a>双重检验锁(DCL)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><strong>缺点：</strong>实现比较复杂，并且由于Java5 以前的JMM（Java 内存模型）存在缺陷，该实现方式会有问题, Java5 和更高的版本可以使用。</p>
<h3 id="u9759_u6001_u5185_u90E8_u7C7B"><a href="#u9759_u6001_u5185_u90E8_u7C7B" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>使用JVM本身机制保证了线程安全问题；SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。</p>
<h3 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法是《Effective Java》上推荐的写法。</em><br><strong>优点</strong>：实现很简单，创建枚举本来就是线程安全的，还能防止反序列化导致重新创建新的对象，直接通过Singleton.INSTANCE来访问实例。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>第一种方法是非线程安全的，不能算正确的写法，有些书上就是这么写的误人子弟啊。 其他方法根据实际情况来选择。<br>一般情况下使用饿汉式写法就可以了，除非有明确要求要用延迟加载（Lazy Loading），这时候可以考虑另外几种实现方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2]]>
    </summary>
    
      <category term="设计模式" scheme="http://yerida.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://yerida.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux write系统调用问题(对齐问题)]]></title>
    <link href="http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/"/>
    <id>http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/</id>
    <published>2012-01-20T12:55:45.000Z</published>
    <updated>2016-01-21T14:33:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((write(<span class="number">1</span>, <span class="string">"Here is some data\n"</span>, <span class="number">18</span>)) != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后在终端中运行，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data</span><br></pre></td></tr></table></figure></p>
<p>如果稍微改变一下write的实参值，将第一个write函数的第三个参数改为17，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>将18改为20，在终端中运行的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data&#10;A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>此程序没有疑问。</p>
<p>程序2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nb;</span><br><span class="line">    nb = (<span class="keyword">int</span>)write(<span class="number">1</span>, <span class="string">"Here is some\n"</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nThe value returned by the function write is %d\n"</span>, nb);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some&#10;A&#10;The value returned by function write is 18</span><br></pre></td></tr></table></figure></p>
<p>程序2运行后，第二行为什么会输出一个A ？ 这个A明显是if语句块里的那个write函数的结果。如果nb的值确实是18，那么按理来说，if语句就不会执行，就不会有这个A；如果nb的值不是18，那么按理第二行应该输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A error has occured on file descriptior 1\n</span><br></pre></td></tr></table></figure></p>
<p>原因分析如下：</p>
<p>常量字符串按顺序存储在常量区域的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34;Here is some\n&#34;&#10;&#34;A error has occured on file descriptior 1\n&#34;</span><br></pre></td></tr></table></figure></p>
<p>这两个常量字符串的地址是紧挨着的, 当第一个字符串的访问越界后就访问到第二个字符串了。</p>
<p>考虑下对齐，指针的地址通常需要是 32 位对齐，也就是 4 的倍数。所以前面的 14 个字符会被多填充两个 0 来对齐到 16 个字节，在加上后面的 A 和一个空格, 刚好 18 个。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1]]>
    </summary>
    
      <category term="C/C++" scheme="http://yerida.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="http://yerida.github.io/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://yerida.github.io/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK安装及环境变量配置]]></title>
    <link href="http://yerida.github.io/2011/01/18/JDK-install/"/>
    <id>http://yerida.github.io/2011/01/18/JDK-install/</id>
    <published>2011-01-18T13:47:55.000Z</published>
    <updated>2016-01-27T14:51:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK官方网站</a>下载最新版本的JDK, 或者从<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="external">JDK Archive</a>找早期的版本（目前JDK6还是很流行的，某些情况下，需要安装早期的版本），这里以JDK6作为例子。</li>
<li>根据操作系统的位数，32位下载X86安装包,  64位的下载X64的安装包。这里以<a href="http://download.oracle.com/otn/java/jdk/6u43-b01/jdk-6u43-windows-i586.exe" target="_blank" rel="external">jdk-6u43-windows-i586.exe</a>为例。</li>
<li>安装的时候，默认是安装在<code>C:\Program Files\Java</code>或者<code>C:\Program Files (x86)\Java</code>路径下，强烈建议不要安装在此路径下，因为这个路径的<code>Program Files</code>目录名中的空格有时候会引起一些问题。建议直接安装在<code>C:\Java</code>路径下。</li>
<li>环境变量配置（右击计算机–&gt;属性–&gt;高级系统设置–&gt;高级–&gt;环境变量）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量值</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JAVA_HOME</td>
<td style="text-align:left"><code>C:\Java\jdk1.6.0_43</code></td>
<td style="text-align:left">JDK安装的目录</td>
</tr>
<tr>
<td style="text-align:left">Path</td>
<td style="text-align:left"><code>;%JAVA_HOME%\bin</code></td>
<td style="text-align:left">在原来的Path变量值后面添加</td>
</tr>
<tr>
<td style="text-align:left">CLASSPATH</td>
<td style="text-align:left"><code>.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar</code></td>
<td style="text-align:left">注意，变量值里面有个”.” ，代表当前路径</td>
</tr>
</tbody>
</table>
<p>5.测试JDK是否安装成功。<strong>新打开</strong>一个cmd命令窗口，输入<code>java –version</code>, 如果有输出JDK的版本信息，则说明安装成功。可以在写个打印”Hello World”的程序测试一下。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><em>这里以<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>为例</em></p>
<ol>
<li>在安装之前，先查看系统是否已经预装了OpenJDK软件，可以在终端执行以下命令。<br><code>java -version</code>如果有输出OpenJDK相关的信息，说明系统已经预装了OpenJDK软件，需要先卸载OpenJDK，卸载方法到网上搜索。</li>
<li>下载安装包<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>。假设安装包下载到<code>/home/yerida/Downloads</code>目录。</li>
<li><p>进入<code>/usr/local</code>目录，在该目录下创建一个java子目录,并进入该java子目录,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span></span><br><span class="line"><span class="variable">$sudo</span> mkdir java</span><br><span class="line"><span class="variable">$cd</span> java</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装包复制到该java目录，并为该安装包添加执行权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> cp /home/yerida/Downloads/jdk-<span class="number">6</span>u45-linux-i586.bin /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$sudo</span> chmod a+x jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行该安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ./jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装后<code>/usr/local/java</code>目录下多了一个<code>jdk1.6.0_45</code>子目录,创建一个软连接指向该目录,并删除安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ln <span class="operator">-s</span> jdk1.<span class="number">6.0</span>_45 jdk  </span><br><span class="line"><span class="variable">$sudo</span> rm jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量。用VIM打开<code>/etc/profile</code>文件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加如下内容，保存并退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk&#10;JRE_HOME=$JAVA_HOME/jre&#10;PATH=$JAVA_HOME/bin:$PATH&#10;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/toos.jar&#10;export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置立即生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Mac_OS_X"><a href="#Mac_OS_X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><p>Mac OS X系统下可以使用<code>brew cask</code>来安装JDK，这种方法非常简单。</p>
<ol>
<li><p>首先用以下命令查找可用的JDK安装包。<br><code>brew cask search java</code></p>
</li>
<li><p>安装最新版本的JDK使用如下命令<br><code>brew cask install java</code></p>
</li>
<li><p>如果要安装其他版本的JDK<br>JDK7安装 <code>brew cask search java7</code><br>JDK6安装 <code>brew cask search java6</code></p>
</li>
<li>测试安装是否成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Mac OS X系统按以上步骤安装好后<strong>无需</strong>在配置JAVA_HOME环境变量,如果系统安装了多个JDK，使用IDE开发的时候可以指定具体的版本，终端下可以使用<code>/usr/libexec/java_home</code>命令来查找JAVA_HOME或者切换JDK版本。参考Apple官方文档：<a href="https://developer.apple.com/library/mac/qa/qa1170/_index.html" target="_blank" rel="external">Important Java Directories on Mac OS X</a></p>
<h1 id="Hello_World_u6D4B_u8BD5_u7A0B_u5E8F"><a href="#Hello_World_u6D4B_u8BD5_u7A0B_u5E8F" class="headerlink" title="Hello World测试程序"></a>Hello World测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<br><code>$javac HelloWorld.java</code></p>
<p>运行：<br><code>$java HelloWorld</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/]]>
    </summary>
    
      <category term="Java" scheme="http://yerida.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://yerida.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
