<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Daniel's Blog]]></title>
  <subtitle><![CDATA[Stay hungry，Stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yerida.github.io/"/>
  <updated>2016-02-03T15:48:12.000Z</updated>
  <id>http://yerida.github.io/</id>
  
  <author>
    <name><![CDATA[Daniel Ye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[IntelliJ IDEA 15常用快捷键(Mac)]]></title>
    <link href="http://yerida.github.io/2015/05/13/intellij-idea-15-keyboard-shortcuts-you-cannot-miss/"/>
    <id>http://yerida.github.io/2015/05/13/intellij-idea-15-keyboard-shortcuts-you-cannot-miss/</id>
    <published>2015-05-13T07:58:01.000Z</published>
    <updated>2016-02-03T15:48:12.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>通过名字查找功能    <code>⇧⌘A</code></li>
<li>显示可用的功能列表 <code>⌥⏎</code></li>
<li>视图切换    <code>⌥F1</code></li>
<li>在工具窗口切换，编辑器里已打开的文件切换    <code>⌃⇥</code></li>
<li>显示导航栏     <code>⌘↑</code></li>
<li>插入live template.     <code>⌘J</code></li>
<li>Surround with a live template.    <code>⌥⌘J</code></li>
<li>从项目或者其他树形视图编辑条目    <code>⌘↓</code></li>
<li>代码注释和取消注释    <code>⌘/</code>  <code>⌥⌘/</code></li>
<li>通过名字查找类或者文件    <code>⌘O</code>   <code>⇧⌘O</code></li>
<li>复制当前行或者选中的区域    <code>⌘D</code></li>
<li>Incremental expression selection.    <code>⌥↑</code> and <code>⌥↓</code></li>
<li>在当前文件内查找文本    <code>⌘F</code></li>
<li>在当前的项目或者指定的目录查找文本    <code>⇧⌘F</code></li>
<li>Search everywhere.    <code>按两下Shift</code></li>
<li>Quick view the usages of the selected symbol.    <code>⇧⌘F7</code></li>
<li>在编辑器里展开或折叠代码块     <code>⌘+</code>  <code>⌘-</code></li>
<li>Invoke code completion.    <code>⌃Space</code></li>
<li>Smart statement completion.    <code>⇧⌘⏎</code></li>
<li><p>代码智能补全    <code>⌃⇧Space</code></p>
<p>完整快捷键列表:<a href="https://www.jetbrains.com/idea/help/keyboard-shortcuts-by-category.html" target="_blank" rel="external">https://www.jetbrains.com/idea/help/keyboard-shortcuts-by-category.html</a></p>
<p>Keymap:<a href="https://www.jetbrains.com/idea/help/keymap.html" target="_blank" rel="external">https://www.jetbrains.com/idea/help/keymap.html</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>通过名字查找功能    <code>⇧⌘A</code></li>
<li>显示可用的功能列表 <code>⌥⏎</code></li>
<li>视图切换    <code>⌥F1</code></li>
<li>在工具窗口切换，编辑器里已打开的文件切换    ]]>
    </summary>
    
      <category term="IDE" scheme="http://yerida.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解Git]]></title>
    <link href="http://yerida.github.io/2014/03/02/visual-git-guide/"/>
    <id>http://yerida.github.io/2014/03/02/visual-git-guide/</id>
    <published>2014-03-02T05:42:33.000Z</published>
    <updated>2016-02-03T13:19:54.000Z</updated>
    <content type="html"><![CDATA[<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h2><p><img src="http://marklodato.github.io/visual-git-guide/basic-usage.svg" alt=""></p>
<p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p>
<ul>
<li><code>git add files</code> 把当前文件放入暂存区域。</li>
<li><code>git commit</code> 给暂存区域生成快照并提交。</li>
<li><code>git reset -- files</code> 用来撤销最后一次<code>git add files</code>，你也可以用<code>git reset</code> 撤销所有暂存区域文件。</li>
<li><code>git checkout -- files</code> 把文件从暂存区域复制到工作目录，用来丢弃本地修改。<br>你可以用 <code>git reset -p</code>, <code>git checkout -p</code>, or <code>git add -p</code>进入交互模式。</li>
</ul>
<p>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/basic-usage-2.svg" alt=""></p>
<ul>
<li><code>git commit -a</code> 相当于运行 <code>git add</code> 把所有当前目录下的文件加入暂存区域再运行 <code>git commit</code>.</li>
<li><code>git commit files</code> 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。</li>
<li><code>git checkout HEAD -- files</code> 回滚到复制最后一次提交。</li>
</ul>
<h2 id="u7EA6_u5B9A"><a href="#u7EA6_u5B9A" class="headerlink" title="约定"></a>约定</h2><p>后文中以下面的形式使用图片。<br><img src="http://marklodato.github.io/visual-git-guide/conventions.svg" alt=""></p>
<p>绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的<em>HEAD</em>标识。 这张图片里显示最后5次提交，<em>ed489</em>是最新提交。 <em>master</em>分支指向此次提交，另一个<em>maint</em>分支指向祖父提交节点。</p>
<h2 id="u547D_u4EE4_u8BE6_u89E3"><a href="#u547D_u4EE4_u8BE6_u89E3" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>有许多种方法查看两次提交之间的变动。下面是一些示例。<br><img src="http://marklodato.github.io/visual-git-guide/diff.svg" alt=""></p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>commit</code>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。<br><img src="http://marklodato.github.io/visual-git-guide/commit-master.svg" alt=""></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。此时，合并(<code>merge</code>) 或者 衍合(<code>rebase</code>) 是必须的。<br><img src="http://marklodato.github.io/visual-git-guide/commit-maint.svg" alt=""></p>
<p>如果想更改一次提交，使用 <code>git commit --amend</code>。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p>另一个例子是分离HEAD提交,后文讲。</p>
<h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p><code>checkout</code>命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>当给定某个文件名（或者打开｀-p｀选项，或者文件名和｀-p｀选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，<code>git checkout HEAD~ foo.c</code>会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-files.svg" alt=""></p>
<p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的<em>a47c3</em>）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（<em>ed489</em>）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-branch.svg" alt=""></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像master~3类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行<code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说<code>git checkout master</code>。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在下面。<br><img src="http://marklodato.github.io/visual-git-guide/checkout-detached.svg" alt=""></p>
<p><strong>HEAD标识处于分离状态时的提交操作</strong></p>
<p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p>
<p><img src="http://marklodato.github.io/visual-git-guide/commit-detached.svg" alt=""></p>
<p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/checkout-after-detached.svg" alt=""></p>
<p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b name</code>来创建一个新的分支。<br><img src="http://marklodato.github.io/visual-git-guide/checkout-b-detached.svg" alt=""></p>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p><code>reset</code>命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用<code>--hard</code>选项，那么工作目录也更新，如果用<code>--soft</code>选项，那么都不变。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset-commit.svg" alt=""></p>
<p>如果没有给出提交点的版本号，那么默认用<em>HEAD</em>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用<code>--hard</code>选项，工作目录也同样。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset.svg" alt=""></p>
<p>如果给了文件名(或者 <code>-p</code>选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/reset-files.svg" alt=""></p>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>merge</code> 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致<em>fast-forward</em>合并。指向只是简单的移动，并生成一个新的提交。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/merge-ff.svg" alt=""></p>
<p>否则就是一次真正的合并。默认把当前提交(<em>ed489</em> 如下所示)和另一个提交(<em>33104</em>)以及他们的共同祖父节点(<em>b325c</em>)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。<br><img src="http://marklodato.github.io/visual-git-guide/merge.svg" alt=""></p>
<h3 id="Cherry_Pick"><a href="#Cherry_Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h3><p><code>cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。<br><img src="http://marklodato.github.io/visual-git-guide/cherry-pick.svg" alt=""></p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>rebase</code>(衍合)是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick<br><img src="http://marklodato.github.io/visual-git-guide/rebase.svg" alt=""></p>
<p>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支，在<em>master</em>分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p>
<p>要限制回滚范围，使用<code>--onto</code>选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p>
<p><img src="http://marklodato.github.io/visual-git-guide/rebase-onto.svg" alt=""></p>
<p>同样有<code>git rebase --interactive</code>让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。没有图片体现这些，细节看这里:<a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode" target="_blank" rel="external">git-rebase(1)</a></p>
<h2 id="u6280_u672F_u8BF4_u660E"><a href="#u6280_u672F_u8BF4_u660E" class="headerlink" title="技术说明"></a>技术说明</h2><p>文件内容并没有真正存储在索引(<em>.git/index</em>)或者提交对象中，而是以blob的形式分别存储在数据库中(<em>.git/objects</em>)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(<em>tree</em>)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p>
<p>如果用<code>detached HEAD</code>提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与<code>git commit --amend</code>或者<code>git rebase</code>很像。</p>
<blockquote>
<p>原文地址: <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。</p>
<h2 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink"]]>
    </summary>
    
      <category term="Git" scheme="http://yerida.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <link href="http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/"/>
    <id>http://yerida.github.io/2013/04/26/design-pattern-singleton-pattern/</id>
    <published>2013-04-26T07:18:27.000Z</published>
    <updated>2016-02-03T14:06:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2><p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。</p>
<p><strong>关键点：</strong></p>
<p>单例模式的要点有三个:</p>
<ol>
<li>一是某个类只能有一个实例.</li>
<li>二是它必须自行创建这个实例.</li>
<li>三是它必须自行向整个系统提供这个实例。</li>
</ol>
<p>从具体实现角度来说，就是以下三点：</p>
<ol>
<li>一是单例模式的类只提供私有的构造方法.</li>
<li>二是类定义中含有一个该类的静态私有对象.</li>
<li>三是该类提供了一个静态的公有的方法用于创建或获取它本身的静态私有对象。</li>
</ol>
<h2 id="u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A"><a href="#u5355_u4F8B_u6A21_u5F0FUML_u56FE_3A" class="headerlink" title="单例模式UML图:"></a>单例模式UML图:</h2><p><img src="https://raw.githubusercontent.com/yerida/BlogImage/master/designpattern/uml_singleton.jpg" alt=""></p>
<h2 id="u5B9E_u73B0_u65B9_u5F0F_uFF1A"><a href="#u5B9E_u73B0_u65B9_u5F0F_uFF1A" class="headerlink" title="实现方式："></a>实现方式：</h2><h3 id="u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u975E_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，非线程安全"></a>懒汉式，非线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong>在多线程环境下可能产生多个实例，违背单例原则。</p>
<h3 id="u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是在方法级别上synchronized并不高效，理论上只需要在第一次调用getInstance() 才需要同步操作。 </p>
<h3 id="u997F_u6C49_u5F0F"><a href="#u997F_u6C49_u5F0F" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。在延迟加载的场景并不适用。</p>
<h3 id="u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29"><a href="#u53CC_u91CD_u68C0_u9A8C_u9501_28DCL_29" class="headerlink" title="双重检验锁(DCL)"></a>双重检验锁(DCL)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><strong>缺点：</strong>实现比较复杂，并且由于Java5 以前的JMM（Java 内存模型）存在缺陷，该实现方式会有问题, Java5 和更高的版本可以使用。</p>
<h3 id="u9759_u6001_u5185_u90E8_u7C7B"><a href="#u9759_u6001_u5185_u90E8_u7C7B" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong>使用JVM本身机制保证了线程安全问题；SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。</p>
<h3 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>该方法是《Effective Java》上推荐的写法。</em><br><strong>优点</strong>：实现很简单，创建枚举本来就是线程安全的，还能防止反序列化导致重新创建新的对象，直接通过Singleton.INSTANCE来访问实例。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>第一种方法是非线程安全的，不能算正确的写法，有些书上就是这么写的误人子弟啊。 其他方法根据实际情况来选择。<br>一般情况下使用饿汉式写法就可以了，除非有明确要求要用延迟加载（Lazy Loading），这时候可以考虑另外几种实现方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD"><a href="#u5355_u4F8B_u6A21_u5F0F_u4ECB_u7ECD" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2]]>
    </summary>
    
      <category term="设计模式" scheme="http://yerida.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://yerida.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux write系统调用问题(对齐问题)]]></title>
    <link href="http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/"/>
    <id>http://yerida.github.io/2012/01/20/Linux-Write-System-Call-Problem/</id>
    <published>2012-01-20T12:55:45.000Z</published>
    <updated>2016-01-21T14:33:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((write(<span class="number">1</span>, <span class="string">"Here is some data\n"</span>, <span class="number">18</span>)) != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后在终端中运行，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data</span><br></pre></td></tr></table></figure></p>
<p>如果稍微改变一下write的实参值，将第一个write函数的第三个参数改为17，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>将18改为20，在终端中运行的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some data&#10;A error has occured on file descriptior 1</span><br></pre></td></tr></table></figure></p>
<p>此程序没有疑问。</p>
<p>程序2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nb;</span><br><span class="line">    nb = (<span class="keyword">int</span>)write(<span class="number">1</span>, <span class="string">"Here is some\n"</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>, <span class="string">"A error has occured on file descriptior 1\n"</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nThe value returned by the function write is %d\n"</span>, nb);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is some&#10;A&#10;The value returned by function write is 18</span><br></pre></td></tr></table></figure></p>
<p>程序2运行后，第二行为什么会输出一个A ？ 这个A明显是if语句块里的那个write函数的结果。如果nb的值确实是18，那么按理来说，if语句就不会执行，就不会有这个A；如果nb的值不是18，那么按理第二行应该输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A error has occured on file descriptior 1\n</span><br></pre></td></tr></table></figure></p>
<p>原因分析如下：</p>
<p>常量字符串按顺序存储在常量区域的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34;Here is some\n&#34;&#10;&#34;A error has occured on file descriptior 1\n&#34;</span><br></pre></td></tr></table></figure></p>
<p>这两个常量字符串的地址是紧挨着的, 当第一个字符串的访问越界后就访问到第二个字符串了。</p>
<p>考虑下对齐，指针的地址通常需要是 32 位对齐，也就是 4 的倍数。所以前面的 14 个字符会被多填充两个 0 来对齐到 16 个字节，在加上后面的 A 和一个空格, 刚好 18 个。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习Linux C 编程，碰到一个关于write系统调用的疑问。</p>
<p>程序1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1]]>
    </summary>
    
      <category term="C/C++" scheme="http://yerida.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="http://yerida.github.io/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://yerida.github.io/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK安装及环境变量配置]]></title>
    <link href="http://yerida.github.io/2011/01/18/JDK-install/"/>
    <id>http://yerida.github.io/2011/01/18/JDK-install/</id>
    <published>2011-01-18T13:47:55.000Z</published>
    <updated>2016-01-27T14:51:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK官方网站</a>下载最新版本的JDK, 或者从<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="external">JDK Archive</a>找早期的版本（目前JDK6还是很流行的，某些情况下，需要安装早期的版本），这里以JDK6作为例子。</li>
<li>根据操作系统的位数，32位下载X86安装包,  64位的下载X64的安装包。这里以<a href="http://download.oracle.com/otn/java/jdk/6u43-b01/jdk-6u43-windows-i586.exe" target="_blank" rel="external">jdk-6u43-windows-i586.exe</a>为例。</li>
<li>安装的时候，默认是安装在<code>C:\Program Files\Java</code>或者<code>C:\Program Files (x86)\Java</code>路径下，强烈建议不要安装在此路径下，因为这个路径的<code>Program Files</code>目录名中的空格有时候会引起一些问题。建议直接安装在<code>C:\Java</code>路径下。</li>
<li>环境变量配置（右击计算机–&gt;属性–&gt;高级系统设置–&gt;高级–&gt;环境变量）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量值</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JAVA_HOME</td>
<td style="text-align:left"><code>C:\Java\jdk1.6.0_43</code></td>
<td style="text-align:left">JDK安装的目录</td>
</tr>
<tr>
<td style="text-align:left">Path</td>
<td style="text-align:left"><code>;%JAVA_HOME%\bin</code></td>
<td style="text-align:left">在原来的Path变量值后面添加</td>
</tr>
<tr>
<td style="text-align:left">CLASSPATH</td>
<td style="text-align:left"><code>.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar</code></td>
<td style="text-align:left">注意，变量值里面有个”.” ，代表当前路径</td>
</tr>
</tbody>
</table>
<p>5.测试JDK是否安装成功。<strong>新打开</strong>一个cmd命令窗口，输入<code>java –version</code>, 如果有输出JDK的版本信息，则说明安装成功。可以在写个打印”Hello World”的程序测试一下。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><em>这里以<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>为例</em></p>
<ol>
<li>在安装之前，先查看系统是否已经预装了OpenJDK软件，可以在终端执行以下命令。<br><code>java -version</code>如果有输出OpenJDK相关的信息，说明系统已经预装了OpenJDK软件，需要先卸载OpenJDK，卸载方法到网上搜索。</li>
<li>下载安装包<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-i586.bin" target="_blank" rel="external">jdk-6u45-linux-i586.bin</a>。假设安装包下载到<code>/home/yerida/Downloads</code>目录。</li>
<li><p>进入<code>/usr/local</code>目录，在该目录下创建一个java子目录,并进入该java子目录,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span></span><br><span class="line"><span class="variable">$sudo</span> mkdir java</span><br><span class="line"><span class="variable">$cd</span> java</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装包复制到该java目录，并为该安装包添加执行权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> cp /home/yerida/Downloads/jdk-<span class="number">6</span>u45-linux-i586.bin /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$cd</span> /usr/<span class="built_in">local</span>/java  </span><br><span class="line"><span class="variable">$sudo</span> chmod a+x jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行该安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ./jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装后<code>/usr/local/java</code>目录下多了一个<code>jdk1.6.0_45</code>子目录,创建一个软连接指向该目录,并删除安装包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ln <span class="operator">-s</span> jdk1.<span class="number">6.0</span>_45 jdk  </span><br><span class="line"><span class="variable">$sudo</span> rm jdk-<span class="number">6</span>u45-linux-i586.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量。用VIM打开<code>/etc/profile</code>文件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加如下内容，保存并退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk&#10;JRE_HOME=$JAVA_HOME/jre&#10;PATH=$JAVA_HOME/bin:$PATH&#10;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/toos.jar&#10;export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置立即生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Mac_OS_X"><a href="#Mac_OS_X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><p>Mac OS X系统下可以使用<code>brew cask</code>来安装JDK，这种方法非常简单。</p>
<ol>
<li><p>首先用以下命令查找可用的JDK安装包。<br><code>brew cask search java</code></p>
</li>
<li><p>安装最新版本的JDK使用如下命令<br><code>brew cask install java</code></p>
</li>
<li><p>如果要安装其他版本的JDK<br>JDK7安装 <code>brew cask search java7</code><br>JDK6安装 <code>brew cask search java6</code></p>
</li>
<li>测试安装是否成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Mac OS X系统按以上步骤安装好后<strong>无需</strong>在配置JAVA_HOME环境变量,如果系统安装了多个JDK，使用IDE开发的时候可以指定具体的版本，终端下可以使用<code>/usr/libexec/java_home</code>命令来查找JAVA_HOME或者切换JDK版本。参考Apple官方文档：<a href="https://developer.apple.com/library/mac/qa/qa1170/_index.html" target="_blank" rel="external">Important Java Directories on Mac OS X</a></p>
<h1 id="Hello_World_u6D4B_u8BD5_u7A0B_u5E8F"><a href="#Hello_World_u6D4B_u8BD5_u7A0B_u5E8F" class="headerlink" title="Hello World测试程序"></a>Hello World测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<br><code>$javac HelloWorld.java</code></p>
<p>运行：<br><code>$java HelloWorld</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol>
<li>从<a href="http://www.oracle.com/technetwork/]]>
    </summary>
    
      <category term="Java" scheme="http://yerida.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://yerida.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
